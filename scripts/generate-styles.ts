import {
  camelCase,
  curry,
  groupBy,
  isPlainObject,
  kebabCase,
  omit,
  partition,
} from 'es-toolkit'
import { get, has, reduce } from 'es-toolkit/compat'
import StyleDictionary from 'style-dictionary'
import {
  logBrokenReferenceLevels,
  logVerbosityLevels,
  logWarningLevels,
  transformGroups,
  transforms,
} from 'style-dictionary/enums'
import {
  type DesignTokens,
  type TransformedToken,
  type TransformedTokens,
} from 'style-dictionary/types'
import { fileHeader } from 'style-dictionary/utils'

import { defineTemplate } from '~/shared/helpers/template'

type TokenEntry = [prop: string, value: string]

type BreakpointMixinData = {
  mixinName: string
  tokenValue: unknown
  selectorProperty: string
}
type TypographyMixinData = {
  mixinName: string
  desktop: string
  mobile: string
}

type ColorMediaTokensData = {
  darkTokens: string
  lightTokens: string
  defaultTokens: string
  mediaTokens: string
}

type SimplifiedTokens = { [key: string]: string | number | SimplifiedTokens }

const buildPath = 'src/styles/'

const portfolioCssDestinations = Object.freeze({
  scheme: 'design/scheme.css',
  variables: 'design/variables.css',
})

const portfolioScssDestinations = Object.freeze({
  blurVariables: 'design/variables/_blur.scss',
  borderVariables: 'design/variables/_border.scss',
  breakpointVariables: 'design/variables/_breakpoints.scss',
  colorVariables: 'design/variables/_colors.scss',
  opacityVariables: 'design/variables/_opacity.scss',
  sizeVariables: 'design/variables/_sizes.scss',
  spacingVariables: 'design/variables/_spacing.scss',
  schemeMixins: 'design/variables/_scheme.scss',
  shadowVariables: 'design/variables/_shadows.scss',
  transitionVariables: 'design/variables/_transitions.scss',
  zIndexVariables: 'design/variables/_zIndex.scss',
  breakpointMixins: 'design/mixins/_breakpoints.scss',
  typographyMixins: 'design/mixins/_typography.scss',
})

const portfolioTsDestinations = Object.freeze({
  tsVariables: 'design/variables.ts',
})

const portfolioFileHeaders = Object.freeze({
  default: 'portfolio-headers/default',
})

const portfolioFormats = Object.freeze({
  cssScheme: 'portfolio-formats/css/scheme',
  cssVariables: 'portfolio-formats/css/variables',
  scssBreakpoint: 'portfolio-formats/scss/breakpoint',
  scssIndex: 'portfolio-formats/scss/index',
  scssScheme: 'portfolio-formats/scss/scheme',
  scssTypography: 'portfolio-formats/scss/typography',
  scssVariables: 'portfolio-formats/scss/variables',
  tsVariables: 'portfolio-formats/ts/variables',
})

const portfolioParsers = Object.freeze({
  webJson: 'portfolio-parsers/web/json-parser',
})

const createEnumFilter = curry((items: unknown[], value: unknown) =>
  items.includes(value),
)

const createRootWithTokens = defineTemplate<{ tokens: string }>`
  :root {
    <%= data.tokens %>
  }
`

const createSchemeColorTokens = defineTemplate<ColorMediaTokensData>`
  @media (prefers-color-scheme: dark) {
    :root {
      <%= data.darkTokens %>
    }
  }

  @media (prefers-color-scheme: light) {
    :root {
      <%= data.lightTokens %>
    }
  }

  :root {
    <%= data.defaultTokens %>
  }

  :is([data-media]) {
    <%= data.mediaTokens %>
  }
`

const createBreakpointMixin = defineTemplate<BreakpointMixinData>`
  @mixin <%= data.mixinName %> {
    @media (<%= data.selectorProperty %>: <%= data.tokenValue %>) {
      @content;
    }
  }
`

const createTypographyMixin = defineTemplate<TypographyMixinData>`
  @mixin <%= data.mixinName %> {
    <%= data.desktop %>
    
    @include media-tablet-md-down {
      <%= data.mobile %>
    }
  }
`

async function run() {
  registerFileHeaders()
  registerFormats()
  registerParsers()

  const webStyleDictionary = await getStyleDictionary()

  await webStyleDictionary.buildAllPlatforms()
}

function registerFileHeaders() {
  StyleDictionary.registerFileHeader({
    name: portfolioFileHeaders.default,
    fileHeader: () => [
      '=============================================================================',
      'THIS IS AN AUTOGENERATED FILE FROM "Generate Styles" SCRIPT!',
      '=============================================================================',
      'Created by Yuri Uliam',
    ],
  })
}

function registerFormats() {
  const typographyAndSchemeKeys = ['typography', 'scheme']
  const isTypographyOrScheme = createEnumFilter(typographyAndSchemeKeys)

  const spaces2 = ' '.repeat(2)
  const spaces4 = ' '.repeat(4)

  StyleDictionary.registerFormat({
    name: portfolioFormats.cssScheme,
    format: async ({ dictionary, file }) => {
      const header = await fileHeader({ file })

      const tokenEntries = toTokenEntries(dictionary.tokenMap.values())
      const schemeTokens = groupBy(
        tokenEntries
          .filter(([, token]) => token.attributes?.category === 'scheme')
          .map(([, token]) => token),
        token => token.path.splice(2, 1).at(0)!, // intentionally removing "dark" and "light" keywords from tokens.
      )

      const tokenMap = new Map(tokenEntries)

      const parsedTokens = Object.fromEntries(
        Object.entries(schemeTokens).map(([type, tokens]) =>
          toEntry(
            type,
            tokens.map(token => {
              const parsedToken = parseToken(token, tokenMap)

              return `${parsedToken.css.var}: ${parsedToken.css.value};`
            }),
          ),
        ),
      )

      const tokens = createSchemeColorTokens({
        darkTokens: parsedTokens.dark!.join(`\n${spaces4}`),
        defaultTokens: parsedTokens.default!.join(`\n${spaces2}`),
        lightTokens: parsedTokens.light!.join(`\n${spaces4}`),
        mediaTokens: parsedTokens.media!.join(`\n${spaces2}`),
      })

      return `${header}${tokens}\n`
    },
  })

  StyleDictionary.registerFormat({
    name: portfolioFormats.cssVariables,
    format: async ({ dictionary, file }) => {
      const header = await fileHeader({ file })

      const tokens = Array.from(dictionary.tokenMap.values())
        .filter(token => !isTypographyOrScheme(token.attributes?.category))
        .map(token => {
          const parsedToken = parseToken(token)

          return `${parsedToken.css.var}: ${parsedToken.css.value};`
        })
        .join(`\n${spaces2}`)

      const rootTokens = createRootWithTokens({ tokens })

      return `${header}${rootTokens}\n`
    },
  })

  StyleDictionary.registerFormat({
    name: portfolioFormats.scssBreakpoint,
    format: async ({ dictionary, file }) => {
      const header = await fileHeader({ file })

      const mixins = Array.from(dictionary.tokenMap.values())
        .flatMap(token => {
          const mixinName = `media ${token.name.replace('breakpoint-', '')}`
          return [
            createBreakpointMixin({
              mixinName: kebabCase(mixinName),
              tokenValue: token.$value,
              selectorProperty: 'min-width',
            }),
            createBreakpointMixin({
              mixinName: kebabCase(`${mixinName} down`),
              tokenValue: `calc(${token.$value} - 1px)`,
              selectorProperty: 'max-width',
            }),
          ]
        })
        .join('\n\n')

      return `${header}${mixins}\n`
    },
  })

  StyleDictionary.registerFormat({
    name: portfolioFormats.scssIndex,
    format: async ({ file }) => {
      const header = await fileHeader({ file })

      const body = Object.values(portfolioScssDestinations)
        .map(relativePath => `@forward "~/styles/${relativePath}";`)
        .join('\n')

      return `${header}${body}\n`
    },
  })

  StyleDictionary.registerFormat({
    name: portfolioFormats.scssScheme,
    format: async ({ dictionary, file }) => {
      const header = await fileHeader({ file })

      const tokenEntries = toTokenEntries(dictionary.tokenMap.values())
      const schemeTokens = groupBy(
        tokenEntries
          .filter(([, token]) => token.attributes?.category === 'scheme')
          .map(([, token]) => token),
        token => token.path.splice(2, 1).at(0)!,
      )

      const tokenMap = new Map(tokenEntries)

      const schemeTokenEntries = Object.entries(schemeTokens)
      const parsedTokens = Object.fromEntries(
        schemeTokenEntries.map(([type, tokens]) => [
          type,
          tokens.map(token => {
            const parsedToken = parseToken(token, tokenMap)

            return `${parsedToken.scss.var}: ${parsedToken.css.asValue};`
          }),
        ]),
      )

      const tokens = [
        parsedTokens.light!.join('\n'),
        parsedTokens.dark!.join('\n'),
        parsedTokens.default!.join('\n'),
        parsedTokens.media!.join('\n'),
      ].join('\n')

      return `${header}${tokens}\n`
    },
  })

  StyleDictionary.registerFormat({
    name: portfolioFormats.scssTypography,
    format: async ({ dictionary, file }) => {
      const header = await fileHeader({ file })
      const imports = `@use "~/styles/${portfolioScssDestinations.breakpointMixins}" as *;`

      const tokenEntries = Array.from(
        dictionary.unfilteredTokenMap?.entries() ?? [],
      )
      const parsedTokens = new Map(
        tokenEntries.map(([tokenKey, token]) => {
          const parsedToken = parseToken(token)

          return [tokenKey, parsedToken.css.asValue]
        }),
      )

      const [desktopTypographyTokens, mobileTypographyTokens] = partition(
        Array.from(dictionary.tokenMap.values()),
        token => token.name.startsWith('typography-desktop'),
      )

      const typographyEntries = desktopTypographyTokens.map(desktopToken => {
        const name = desktopToken.name.split('-').slice(2).join('-')
        const mobile = mobileTypographyTokens.find(mobileToken =>
          mobileToken.name.endsWith(name),
        )!

        const desktopTypography = Object.entries(
          desktopToken.original.$value as Record<string, string>,
        )

        const mobileTypography = Object.entries(
          mobile.original.$value as Record<string, string>,
        )

        return { name, desktopTypography, mobileTypography }
      })

      const mixins = typographyEntries
        .map(({ name, desktopTypography, mobileTypography }) =>
          createTypographyMixin({
            mixinName: name,
            desktop: desktopTypography
              .map(([prop, value]) =>
                tokenEntryToString([
                  kebabCase(prop),
                  parsedTokens.get(value) ?? value,
                ]),
              )
              .join(`\n${spaces2}`),
            mobile: mobileTypography
              .map(([prop, value]) =>
                tokenEntryToString([
                  kebabCase(prop),
                  parsedTokens.get(value) ?? value,
                ]),
              )
              .join(`\n${spaces4}`),
          }),
        )
        .join('\n\n')

      return `${header}${imports}\n\n${mixins}\n`
    },
  })

  StyleDictionary.registerFormat({
    name: portfolioFormats.scssVariables,
    format: async ({ dictionary, file, options }) => {
      const header = await fileHeader({ file })

      const isByReference = !!options.outputReferences
      const scssTokens = Array.from(dictionary.tokenMap.values())
        .filter(token => !isTypographyOrScheme(token.attributes?.category))
        .map(token => {
          const tokenValue = parseToken(token)
          const scssValue = isByReference
            ? tokenValue.css.asValue
            : tokenValue.css.value

          return `${tokenValue.scss.var}: ${scssValue};`
        })
        .join('\n')

      return `${header}${scssTokens}\n`
    },
  })

  StyleDictionary.registerFormat({
    name: portfolioFormats.tsVariables,
    format: async ({ dictionary, file }) => {
      const header = await fileHeader({ file })

      const tokens = omit(dictionary.tokens, typographyAndSchemeKeys)
      const tsTokens = simplifyTokens(tokens)

      const tsBody = `export const tokens = ${JSON.stringify(tsTokens, null, 2)}`

      return `${header}${tsBody}\n`
    },
  })
}

function registerParsers() {
  StyleDictionary.registerParser({
    name: portfolioParsers.webJson,
    pattern: /\.json$/,
    parser: ({ contents }) => {
      const parsedContents = JSON.parse(contents) as DesignTokens

      if (isPlainObject(parsedContents.breakpoint)) {
        return {
          breakpoint: Object.entries<unknown>(parsedContents.breakpoint).reduce(
            (acc, [prop, value]) => ({
              ...acc,
              [kebabCase(prop.replaceAll(':', ' '))]: value,
            }),
            {},
          ),
        }
      }

      if (isPlainObject(parsedContents.typography)) {
        const { typography } = parsedContents
        const typographyCategory = ['desktop', 'mobile']
        const typographyIntent = ['body', 'display', 'link']

        // Converts [<typography>.<category>.<intent>.<size>]
        // to [<typography>.<category-intent-size>]
        return {
          typography: typographyCategory.reduce(
            (accTypes, category) => ({
              ...accTypes,
              ...typographyIntent.reduce(
                (accIntents, intent) => ({
                  ...accIntents,
                  ...Object.entries(
                    get(typography, [category, intent], {}) as DesignTokens,
                  ).reduce(
                    (acc, [prop, token]) => ({
                      ...acc,
                      [kebabCase(
                        `${category} ${intent} ${prop.replaceAll(':', ' ')}`,
                      )]: token,
                    }),
                    {},
                  ),
                }),
                {},
              ),
            }),
            {},
          ),
        }
      }

      return parsedContents
    },
  })
}

async function getStyleDictionary() {
  const baseStyleDictionary = new StyleDictionary({
    parsers: [portfolioParsers.webJson],
    log: {
      verbosity: logVerbosityLevels.verbose,
      warnings: logWarningLevels.error,
      errors: { brokenReferences: logBrokenReferenceLevels.throw },
    },
  })

  const webStyleDictionary = await baseStyleDictionary.extend({
    source: ['configs/tokens/**/*.json'],
    platforms: {
      css: {
        transformGroup: transformGroups.css,
        transforms: [transforms.attributeCti],
        buildPath,
        options: { fileHeader: portfolioFileHeaders.default },
        files: [
          {
            destination: portfolioCssDestinations.variables,
            format: portfolioFormats.cssVariables,
          },
          {
            destination: portfolioCssDestinations.scheme,
            format: portfolioFormats.cssScheme,
          },
        ],
      },

      scss: {
        transformGroup: transformGroups.scss,
        transforms: [transforms.attributeCti],
        buildPath,
        files: [
          {
            destination: portfolioScssDestinations.blurVariables,
            format: portfolioFormats.scssVariables,
            filter: { attributes: { category: 'blur' } },
            options: { outputReferences: true },
          },
          {
            destination: portfolioScssDestinations.borderVariables,
            format: portfolioFormats.scssVariables,
            filter: { attributes: { category: 'border' } },
            options: { outputReferences: true },
          },
          {
            destination: portfolioScssDestinations.breakpointVariables,
            format: portfolioFormats.scssVariables,
            filter: { attributes: { category: 'breakpoint' } },
            options: { outputReferences: false },
          },
          {
            destination: portfolioScssDestinations.colorVariables,
            format: portfolioFormats.scssVariables,
            filter: { attributes: { category: 'color' } },
            options: { outputReferences: true },
          },
          {
            destination: portfolioScssDestinations.opacityVariables,
            format: portfolioFormats.scssVariables,
            filter: { attributes: { category: 'opacity' } },
            options: { outputReferences: true },
          },
          {
            destination: portfolioScssDestinations.sizeVariables,
            format: portfolioFormats.scssVariables,
            filter: { attributes: { category: 'size' } },
            options: { outputReferences: true },
          },
          {
            destination: portfolioScssDestinations.spacingVariables,
            format: portfolioFormats.scssVariables,
            filter: { attributes: { category: 'spacing' } },
            options: { outputReferences: true },
          },
          {
            destination: portfolioScssDestinations.shadowVariables,
            format: portfolioFormats.scssVariables,
            filter: { attributes: { category: 'shadow' } },
            options: { outputReferences: true },
          },
          {
            destination: portfolioScssDestinations.transitionVariables,
            format: portfolioFormats.scssVariables,
            filter: { attributes: { category: 'transition' } },
            options: { outputReferences: true },
          },
          {
            destination: portfolioScssDestinations.zIndexVariables,
            format: portfolioFormats.scssVariables,
            filter: { attributes: { category: 'zIndex' } },
            options: { outputReferences: true },
          },
          {
            destination: 'design/_index.scss',
            format: portfolioFormats.scssIndex,
          },
          {
            destination: portfolioScssDestinations.schemeMixins,
            format: portfolioFormats.scssScheme,
          },
        ],
        options: { fileHeader: portfolioFileHeaders.default },
      },

      scssMixins: {
        transformGroup: transformGroups.scss,
        transforms: [transforms.attributeCti],
        buildPath,
        options: { fileHeader: portfolioFileHeaders.default },
        files: [
          {
            destination: portfolioScssDestinations.breakpointMixins,
            format: portfolioFormats.scssBreakpoint,
            filter: { attributes: { category: 'breakpoint' } },
          },
          {
            destination: portfolioScssDestinations.typographyMixins,
            format: portfolioFormats.scssTypography,
            filter: { attributes: { category: 'typography' } },
          },
        ],
      },

      ts: {
        transformGroup: transformGroups.js,
        transforms: [transforms.attributeCti, transforms.nameCamel],
        buildPath,
        options: { fileHeader: portfolioFileHeaders.default },
        files: [
          {
            destination: portfolioTsDestinations.tsVariables,
            format: portfolioFormats.tsVariables,
          },
        ],
      },
    },
  })

  await webStyleDictionary.hasInitialized

  return webStyleDictionary
}

function simplifyTokens(token: TransformedToken): string | number
function simplifyTokens(tokens: TransformedTokens): SimplifiedTokens
function simplifyTokens(
  tokens: TransformedTokens | TransformedToken,
): string | number | SimplifiedTokens {
  if (has(tokens, '$value')) return tokens.$value as string | number

  return reduce(
    tokens,
    (acc, value, key) => {
      if (!isPlainObject(value)) return acc

      return { ...acc, [key]: simplifyTokens(value) }
    },
    {},
  )
}

function tokenEntryToString(entry: Readonly<TokenEntry>) {
  return `${entry[0]}: ${entry[1]};`
}

function toEntry<TKey extends string, TValue>(key: TKey, value: TValue) {
  return Object.freeze<[key: TKey, value: TValue]>([key, value])
}

function toTokenEntries(tokens: Iterable<TransformedToken>) {
  return Array.from(tokens).map<[string, TransformedToken]>(token => [
    token.key!,
    token,
  ])
}

function parseToken(
  token: TransformedToken,
  tokens?: Map<string, TransformedToken>,
) {
  const tokenName = token.path.join(' ')
  const kebabName = kebabCase(tokenName)
  const camelName = camelCase(tokenName)

  const cssVar = `--${kebabName}`
  const scssVar = `$${camelName}`

  const tokenRef = tokens?.get(token.original.$value as string)
  const tokenValue = (
    tokenRef ? parseToken(tokenRef).css.asValue : token.$value
  ) as string

  return {
    key: kebabName,
    css: { var: `${cssVar}`, asValue: `var(${cssVar})`, value: tokenValue },
    scss: { var: scssVar },
  }
}

await run()
