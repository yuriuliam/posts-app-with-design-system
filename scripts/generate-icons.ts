import type {
  Component,
  ComponentSet,
  GetFileNodesResponse,
  GetImagesResponse,
} from '@figma/rest-api-spec'

import { kebabCase, camelCase, pascalCase, capitalize } from 'es-toolkit/string'
import { parseHTML } from 'linkedom'
import * as fs from 'node:fs/promises'
import path from 'node:path'
import { VFile } from 'vfile'
import { z } from 'zod'

import { defineTemplate } from '~/shared/helpers/template'
import { tryCatch } from '~/shared/helpers/tryCatch'

type SampleSVGImageData = {
  id: string
  name: string
  componentName: string
  url: string
}

type ParsedSVG = {
  attributes: Record<string, string>
  content: string
  base64: string
  maskProps: Array<Record<string, string>>
}

type SVGImageData = SampleSVGImageData & { svg: ParsedSVG }

const projectRootDir = path.join(import.meta.dirname, '..')

const constants = Object.freeze({
  iconsDir: path.join(projectRootDir, 'src', 'design', 'icons'),
  figma: Object.freeze({
    baseUrl: z.string().url().parse(process.env.FIGMA_BASE_URL),
    fileId: z.string().min(1).parse(process.env.FIGMA_FILE_ID),
    nodeId: z.string().min(1).parse(process.env.FIGMA_NODE_ID),
    token: z.string().min(1).parse(process.env.FIGMA_TOKEN),
    icon: Object.freeze({
      expectedPartialFlagName: 'Full Color/Flag/',
      expectedPartialIconSetName: '$icon-',
      expectedIconName: 'Size=24px',
    }),
  }),
})

const htmlStylePropRegExp = /style="([^"]*)"/g
const htmlElementStrokePropRegExp = /stroke-([^\s]*)/g

const createIconContent = defineTemplate<{
  base64DataUrl: string
  iconComponentName: string
  baseIconName: string
  iconPropsName: string
  iconRefName: string
  svgAttributes: string
  svgContent: string
  svgName: string
}>`
  /**
   * =============================================================================
   * THIS IS AN AUTOGENERATED FILE FROM "Generate Icons" SCRIPT!
   * =============================================================================
   */
  import React from 'react'

  import { <%= data.baseIconName %> } from '~/design/base/icon'
  import { definePortfolioDisplayName } from '~/shared/helpers/displayName'

  type <%= data.iconPropsName %> = React.ComponentPropsWithoutRef<typeof <%= data.baseIconName %>>
  type <%= data.iconRefName %> = React.ComponentRef<typeof <%= data.baseIconName %>>

  /** @preview ![img](<%= data.base64DataUrl %>) */
  const <%= data.iconComponentName %> = React.forwardRef<<%= data.iconRefName %>, <%= data.iconPropsName %>>((props, ref) => <<%= data.baseIconName %> {...props} <%= data.svgAttributes %> data-portfolio-icon-name="<%= data.svgName %>" ref={ref}><%= data.svgContent %></<%= data.baseIconName %>>)
  <%= data.iconComponentName %>.displayName = definePortfolioDisplayName("<%= data.iconComponentName %>")

  export { <%= data.iconComponentName %> }
`

/**
 * This script generates icons from Figma files.
 * It fetches SVG images from Figma, parses them and generates TypeScript files.
 * The generated files are saved in the `src/design/icons` directory.
 *
 * @see https://www.figma.com/developers/api
 */
async function run() {
  const figmaFileData = await fetchFigmaFile(constants.figma.nodeId)
  const iconFileData = Object.values(figmaFileData.nodes).at(0)

  if (!iconFileData) throw new Error('No icon file data found!')

  const { components, componentSets } = iconFileData

  const iconFileComponentSets = parseComponentLikeToObjectWithIds(
    componentSets,
  ).filter(set =>
    set.name.includes(constants.figma.icon.expectedPartialIconSetName),
  )

  const iconComponentSets = await fetchFigmaFile(
    iconFileComponentSets.map(set => set.id).join(','),
  )

  const iconSamples = Object.values(iconComponentSets.nodes).map(item => {
    const iconName = item.document.name
    const iconData = Object.entries(item.components).find(
      ([, componentValue]) =>
        componentValue.name === constants.figma.icon.expectedIconName,
    )

    if (!iconData) throw new Error(`No icon data found for ${iconName}!`)

    const [iconId, iconComponent] = iconData

    return {
      ...iconComponent,
      id: iconId,
      name: iconName,
    }
  })

  const flagSamples = parseComponentLikeToObjectWithIds(components).filter(
    node => node.name.includes(constants.figma.icon.expectedPartialFlagName),
  )

  const flagAndIconSamples = [...flagSamples, ...iconSamples]

  const samplesSVGData = await fetchFigmaSVGs(
    flagAndIconSamples.map(sample => sample.id),
  )

  const samplesSVGImages = flagAndIconSamples.map<SampleSVGImageData>(
    sample => ({
      id: sample.id,
      name: sample.name,
      componentName: pascalCase(
        sample.name
          .replace('Full Color/Flag/', 'flag-')
          .replace('$icon', 'icon'),
      ),
      url: samplesSVGData.images[sample.id]!,
    }),
  )

  const parsedSVGImages = await Promise.all(
    samplesSVGImages.map<Promise<SVGImageData>>(async sample => ({
      ...sample,
      svg: parseRawSvgImage(await fetchSVGImage(sample.url)),
    })),
  )

  const parsedIconFiles = parsedSVGImages.map(parseSVGImageToIconVFile)

  const iconsFolderStats = await fs.lstat(constants.iconsDir)

  if (!iconsFolderStats.isDirectory()) {
    throw new Error(`Path is not a directory: ${constants.iconsDir}`)
  }

  await Promise.all(
    parsedIconFiles.map(async iconVFile => {
      const filePathStat = await fs.lstat(iconVFile.path).catch(() => null)

      if (filePathStat) await fs.rm(iconVFile.path)

      await fs.writeFile(iconVFile.path, iconVFile.value)
    }),
  )
}

function parseComponentLikeToObjectWithIds<T extends Component | ComponentSet>(
  value: Record<string, T>,
) {
  return Object.entries(value).map(([id, sample]) => ({
    id,
    ...sample,
  }))
}

function parseSVGImageToIconVFile(svgImageData: SVGImageData) {
  const { componentName: iconComponentName, svg } = svgImageData

  const parsedSVGAttributes = Object.entries(svg.attributes).reduce(
    (acc, [attrName, attrValue]) => {
      const formattedAttrName = attrName.startsWith('data')
        ? attrName
        : camelCase(attrName)

      return `${acc} ${formattedAttrName}="${attrValue}"`.trim()
    },
    '',
  )

  const parsedSVGContent = svg.content
    .replaceAll('\n', '')
    .replaceAll(
      '#1E2028',
      iconComponentName.startsWith('Flag') ? '#1E2028' : 'currentColor',
    )
    .replace(
      htmlStylePropRegExp,
      `style={${JSON.stringify(svg.maskProps.shift())}}`,
    )
    .replace(
      htmlElementStrokePropRegExp,
      (_, propSuffix) => `stroke${capitalize(propSuffix)}`,
    )

  const iconPropsName = `${iconComponentName}Props`
  const iconRefName = `${iconComponentName}Ref`

  const base64DataUrl = `data:image/svg+xml;base64,${svg.base64}`
  const baseIconName = 'IconBase'

  const content = createIconContent({
    base64DataUrl,
    iconComponentName,
    baseIconName: baseIconName,
    iconPropsName,
    iconRefName,
    svgAttributes: parsedSVGAttributes,
    svgContent: parsedSVGContent,
    svgName: svgImageData.name,
  })
  const partialFileName = kebabCase(iconComponentName)

  const iconFile = new VFile({
    path: path.join(constants.iconsDir, `${partialFileName}.tsx`),
    value: content,
  })

  return iconFile
}

function parseSvgAttributesToJSXFormat(attributes: NamedNodeMap) {
  return Object.fromEntries(
    Object.values(attributes)
      .filter(attr => !!(attr?.name && attr.value))
      .map(attr => [camelCase(attr.name), attr.value]),
  )
}

function parseRawSvgImage(svgData: string) {
  const { document } = parseHTML(svgData)

  const svgElement = document.documentElement

  const svgAttributes = parseSvgAttributesToJSXFormat(svgElement.attributes)

  const defsElement = svgElement.querySelector('defs')
  const gElement = svgElement.querySelector('g')

  // This is likely not supported, so we modify the DOM tree for that!
  if (defsElement && gElement) {
    Array.from(gElement.childNodes).forEach(node => {
      svgElement.appendChild(node)
    })

    svgElement.removeChild(gElement)
    svgElement.removeChild(defsElement)
  }

  const maskElements = Array.from(svgElement.querySelectorAll('mask')).filter(
    maskElement => !!maskElement.getAttribute('style'),
  )

  const maskProps = maskElements.map(maskElement => {
    const maskStyles = maskElement?.getAttribute('style')?.split(';') ?? []

    return Array.from(maskStyles).reduce(
      (acc, cur) => {
        const [key, value] = cur
          .trim()
          .split(':')
          .map(item => item.trim())

        if (!key || !value) return acc

        return {
          ...acc,
          [camelCase(key)]: value,
        }
      },
      {} as Record<string, string>,
    )
  })

  const svgContent = svgElement.innerHTML

  svgElement.setAttribute('style', 'background-color: #fff; border-radius: 2px')

  const base64 = Buffer.from(
    svgElement.outerHTML.replaceAll('\n', ''),
  ).toString('base64')

  svgElement.removeAttribute('style')

  const parsedSVG: ParsedSVG = {
    attributes: svgAttributes,
    content: svgContent,
    base64,
    maskProps,
  }

  return parsedSVG
}

async function fetchSVGImage(url: string) {
  const response = await fetch(url, {
    headers: {
      'X-Figma-Token': constants.figma.token,
      'Content-Type': 'image/svg+xml',
    },
  })

  const { data, error } = await tryCatch(response.text())

  if (!response.ok) {
    const baseMessage = `"fetchSVGImage" failed! (Status: ${response.status})`
    throw new Error(`${baseMessage}\n> Data: ${JSON.stringify(data, null, 2)}`)
  }

  if (error) {
    throw new Error(`"fetchSVGImage" failed to parse TXT response!`)
  }

  return data
}

async function fetchFigmaSVGs(sampleIds: string[]) {
  const baseParams = new URLSearchParams({
    format: 'svg',
    svg_simplify_stroke: 'false',
  })

  const url = new URL(
    `/v1/images/${constants.figma.fileId}?${baseParams}&ids=${sampleIds.join(',')}`,
    constants.figma.baseUrl,
  )

  const response = await fetch(url, {
    headers: {
      'X-Figma-Token': constants.figma.token,
      'Content-Type': 'application/json',
    },
  })

  const { data, error } = await tryCatch(
    response.json() as Promise<GetImagesResponse>,
  )

  if (!response.ok) {
    const baseMessage = `"fetchFigmaSVGs" failed! (Status: ${response.status})`
    throw new Error(`${baseMessage}\n> Data: ${JSON.stringify(data, null, 2)}`)
  }

  if (error) {
    throw new Error(`"fetchFigmaSVGs" failed to parse JSON response!`)
  }

  return data
}

async function fetchFigmaFile(nodeIds: string) {
  const url = new URL(
    `/v1/files/${constants.figma.fileId}/nodes?ids=${nodeIds}`,
    constants.figma.baseUrl,
  )

  const response = await fetch(url, {
    headers: {
      'X-Figma-Token': constants.figma.token,
      'Content-Type': 'application/json',
    },
  })

  const { data, error } = await tryCatch(
    response.json() as Promise<GetFileNodesResponse>,
  )

  if (!response.ok) {
    const baseMessage = `"fetchFigmaFile" failed! (Status: ${response.status})`
    throw new Error(`${baseMessage}\n> Data: ${JSON.stringify(data, null, 2)}`)
  }

  if (error) {
    throw new Error(`"fetchFigmaFile" failed to parse JSON response!`)
  }

  return data
}

await run()
